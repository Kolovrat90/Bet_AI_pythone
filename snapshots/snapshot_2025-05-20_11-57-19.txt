=== Snapshot of C:\Code Projects\Bet_AI_pythone at 2025-05-20 11:57:19.059202 ===

[FILE] app.py (6 KB)
----- begin content -----
# app.py
import os
from datetime import datetime, date, time as dt_time
import streamlit as st
import pandas as pd

from betai.pipelines import scan_days, full_pipeline
from betai.models import allocate_bank

# ‚îÄ‚îÄ Page config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
st.set_page_config(page_title="BetAI ‚Äì Value Betting Scanner", page_icon="‚öΩ", layout="wide")
st.markdown("# ‚öΩ BetAI ‚Äì Value Betting Scanner (MVP)")

# ‚îÄ‚îÄ API-–∫–ª—é—á ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
API_KEY = st.secrets.get("APIFOOTBALL_KEY") or os.getenv("APIFOOTBALL_KEY")
if not API_KEY:
    st.error("–ù—É–∂–µ–Ω –∫–ª—é—á APIFOOTBALL_KEY –≤ .streamlit/secrets.toml –∏–ª–∏ –∫–∞–∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
    st.stop()

# ‚îÄ‚îÄ Inputs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
c0, c1, c2 = st.columns([1, 2, 2])
with c0:
    today_only = st.checkbox("–°–µ–≥–æ–¥–Ω—è", True)
with c1:
    edge_pct = st.slider("–ü–æ—Ä–æ–≥ —Ü–µ–Ω–Ω–æ—Å—Ç–∏, %", 1, 10, 5)
with c2:
    bank = st.number_input("–ë–∞–Ω–∫, ‚Ç¨", min_value=10.0, step=50.0, value=1000.0, format="%.2f")

days = 1 if today_only else st.selectbox("–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –¥–Ω–µ–π –≤–ø–µ—Ä—ë–¥", [1, 2, 3], 0)
top_n = st.selectbox("–¢–æ–ø-–ª–∏–≥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞", [10, 15, 20, 25, 30], 0)

btn_scan = st.button("üîç –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—á–∏", type="primary")
btn_calc = st.button("üí∞ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–∞–≤–∫–∏")

# ‚îÄ‚îÄ Cached calls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@st.cache_data(show_spinner=False)
def _scan(d, e, n):
    return scan_days(d, e, n)

# ‚îÄ‚îÄ –®–∞–≥ 1: —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if btn_scan:
    outs = _scan(days, edge_pct/100.0, top_n)
    st.session_state["outs_raw"] = outs
    st.success(f"–ù–∞–π–¥–µ–Ω–æ {len(outs)} value-–∏—Å—Ö–æ–¥–æ–≤ (edge ‚â• {edge_pct}%)")

# ‚îÄ‚îÄ –í—Å–µ–≥–¥–∞: –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–æ—à–ª—ã–π scan ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º editable —Ç–∞–±–ª–∏—Ü—É ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if "outs_raw" in st.session_state:
    outs = st.session_state["outs_raw"]
    # —Å–æ–±–∏—Ä–∞–µ–º DataFrame
    df = pd.DataFrame(o.model_dump() for o in outs)
    # —Ñ–∏–ª—å—Ç—Ä—É–µ–º —É–∂–µ —Å—ã–≥—Ä–∞–Ω–Ω—ã–µ
    now = datetime.now()
    df = df[df.apply(
        lambda r: datetime.combine(date.fromisoformat(r.date),
                                   dt_time.fromisoformat(r.time)) > now,
        axis=1
    )].reset_index(drop=True)

    # –ø–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–ª–æ–Ω–∫–∏
    df.insert(0, "Use", True)
    df["Edge %"] = (df["edge"]*100).round(1)
    df["Stake ‚Ç¨"] = 0
    df["Flag"] = df["flag_url"]
    df = df.rename(columns={
        "date": "Date", "time": "Time",
        "league": "League", "match": "Match",
        "pick_ru": "Pick", "k_dec": "Min Odds"
    })
    view = df[["Use","Date","Time","Flag","League","Match","Pick","Min Odds","Edge %","Stake ‚Ç¨"]]

    st.session_state["edited"] = st.data_editor(
        view,
        hide_index=True,
        column_config={
            "Use":    st.column_config.CheckboxColumn(),
            "Flag":   st.column_config.ImageColumn("", width="small"),
            "Edge %": st.column_config.NumberColumn(format="%.1f %"),  
            "Stake ‚Ç¨":st.column_config.NumberColumn(format="%d"),
        },
    )

# ‚îÄ‚îÄ –®–∞–≥ 2: —Ä–∞—Å—á—ë—Ç ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if btn_calc:
    if "outs_raw" not in st.session_state or "edited" not in st.session_state:
        st.warning("–°–Ω–∞—á–∞–ª–∞ —Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ –º–∞—Ç—á–∏.")
    else:
        raw = st.session_state["outs_raw"]
        edited = st.session_state["edited"]
        # –∫–∞–∫–æ–π Use = True?
        mask = edited["Use"].tolist()
        kept = [o for o,u in zip(raw, mask) if u]

        if not kept:
            st.warning("–ù–µ—á–µ–≥–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—Ç—å ‚Äî –Ω–∏ –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ –Ω–µ –æ—Ç–º–µ—á–µ–Ω–∞.")
        else:
            # —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–Ω–∫
            allocate_bank(kept, bank)

            # —Å—Ç—Ä–æ–∏–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Ç–∞–±–ª–∏—Ü—É
            rows = []
            for o in kept:
                rows.append({
                    "Date":     o.date,
                    "Time":     o.time,
                    "Flag":     o.flag_url,
                    "League":   o.league,
                    "Match":    o.match,
                    "Pick":     o.pick_ru.replace("–ü–æ–±–µ–¥–∞ —Ö–æ–∑—è–µ–≤","–•–æ–∑—è–µ–≤–∞")
                                      .replace("–ü–æ–±–µ–¥–∞ –≥–æ—Å—Ç–µ–π","–ì–æ—Å—Ç–∏"),
                    "Min Odds": o.k_dec,
                    "Edge %":   f"{o.edge*100:.1f} %",
                    "Stake ‚Ç¨":  int(round(o.stake_eur))
                })
            res = pd.DataFrame(rows)

            # –º–µ—Ç—Ä–∏–∫–∏
            c1, c2, c3, _ = st.columns([1,1,1,5])
            c1.metric("‚åÄ Min Odds", f"{res['Min Odds'].mean():.2f}")
            avg_edge = res["Edge %"].str.rstrip(" %").astype(float).mean()
            c2.metric("‚åÄ Edge %", f"{avg_edge:.1f} %")
            c3.metric("Œ£ Stake ‚Ç¨", f"{res['Stake ‚Ç¨'].sum()}")

            # –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            st.dataframe(
                res,
                use_container_width=True,
                column_config={
                    "Flag":   st.column_config.ImageColumn("", width="small"),
                    "Stake ‚Ç¨":st.column_config.NumberColumn(format="%d"),
                }
            )

-----  end content  -----

[DIR ] betai
[FILE] betai\__init__.py (0 KB)
----- begin content -----
# –ø—É—Å—Ç–æ–π: –ø—Ä–æ—Å—Ç–æ –ø–æ–º–µ—á–∞–µ—Ç –∫–∞—Ç–∞–ª–æ–≥ –∫–∞–∫ –ø–∞–∫–µ—Ç

-----  end content  -----

[FILE] betai\api.py (2 KB)
----- begin content -----
"""
–¢–æ–Ω–∫–∞—è –æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ API-Football v3 + —Ñ–∞–π–ª-–∫–µ—à SQLite.
"""

from __future__ import annotations
import os
import time
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional, Tuple

import requests
from dotenv import load_dotenv
from sqlitedict import SqliteDict

# ---------------------------------------------------------------------
# –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

ROOT = os.path.dirname(os.path.abspath(__file__))
CACHE_FILE = os.path.join(ROOT, "apifootball_cache.sqlite")

load_dotenv()
API_KEY = os.getenv("APIFOOTBALL_KEY")
if not API_KEY:
    raise RuntimeError("API key is required ‚Äì create .env with APIFOOTBALL_KEY=...")

BASE_URL = "https://v3.football.api-sports.io"
HEADERS = {"x-apisports-key": API_KEY}

# TTL –∫–µ—à–∞ (—Å–µ–∫) –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
TTL = {
    "fixtures": 6 * 3600,      # —Ñ–∏–∫—Å—Ç—É—Ä—ã –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è —Ä–∞–∑ –≤ 6 —á
    "odds":      6 * 3600,
    "predictions": 6 * 3600,
}

# ---------------------------------------------------------------------
# –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –¥–æ—Å—Ç—É–ø –∫ –∫–µ—à—É

_cache = SqliteDict(CACHE_FILE, autocommit=True)


def _cache_key(path: str, params: Dict[str, Any]) -> str:
    return f"{path}:" + "&".join(f"{k}={v}" for k, v in sorted(params.items()))


def _get(path: str, params: Dict[str, Any], ttl: int) -> Any:
    key = _cache_key(path, params)
    now = time.time()
    if key in _cache:
        ts, data = _cache[key]
        if now - ts < ttl:
            return data
    resp = requests.get(f"{BASE_URL}/{path}", headers=HEADERS, params=params, timeout=20)
    resp.raise_for_status()
    data = resp.json()
    _cache[key] = (now, data)
    return data


# ---------------------------------------------------------------------
# –ø—É–±–ª–∏—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

def get_fixtures(date: datetime) -> Dict[str, Any]:
    """–§–∏–∫—Å—Ç—É—Ä—ã –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—É—é –¥–∞—Ç—É (UTC)."""
    return _get(
        "fixtures",
        {"date": date.strftime("%Y-%m-%d"), "timezone": "UTC"},
        TTL["fixtures"],
    )


def get_odds(fixture_id: int) -> Dict[str, Any]:
    """–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –º–∞—Ç—á–∞."""
    return _get(
        "odds",
        {"fixture": fixture_id},
        TTL["odds"],
    )


def get_predictions(fixture_id: int) -> Dict[str, Any]:
    """Predictions-—ç–Ω–¥–ø–æ–∏–Ω—Ç API-Football."""
    return _get(
        "predictions",
        {"fixture": fixture_id},
        TTL["predictions"],
    )

-----  end content  -----

[FILE] betai\constants.py (0 KB)
----- begin content -----
"""Static constants: league white‚Äëlist, markets, etc."""

# Top‚Äë10 –µ–≤—Ä–æ–ø–µ–π—Å–∫–∏—Ö –¥–∏–≤–∏–∑–∏–æ–Ω–æ–≤ (id API‚ÄëFootball v3)
TOP_LEAGUES = {
    39,   # EPL –ê–Ω–≥–ª–∏—è
    140,  # –õ–∞ –õ–∏–≥–∞ –ò—Å–ø–∞–Ω–∏—è
    135,  # –°–µ—Ä–∏—è¬†A –ò—Ç–∞–ª–∏—è
    78,   # –ë—É–Ω–¥–µ—Å–ª–∏–≥–∞ –ì–µ—Ä–º–∞–Ω–∏—è
    61,   # –õ–∏–≥–∞¬†1 –§—Ä–∞–Ω—Ü–∏—è
    88,   # –≠—Ä–µ–¥–∏–≤–∏–∑–∏ –ù–∏–¥–µ—Ä–ª–∞–Ω–¥—ã
    94,   # –ü—Ä–∏–º–µ–π—Ä–∞¬†–ü–æ—Ä—Ç—É–≥–∞–ª–∏—è
    253,  # –ü—Ä–µ–º—å–µ—Ä‚Äë–ª–∏–≥–∞ –†–æ—Å—Å–∏—è
    203,  # –ë–µ–ª—å–≥–∏—è Jupiler
    2,    # –õ–∏–≥–∞ –ß–µ–º–ø–∏–æ–Ω–æ–≤ UEFA ‚Äì –≤—ã–Ω–µ—Å–µ–Ω –∫–∞–∫ –º–∞—Ä–∫–µ—Ä —Ç–æ–ø‚Äë—É—Ä–æ–≤–Ω—è
}

EDGE_DEFAULT = 0.05  # 5¬†%
-----  end content  -----

[FILE] betai\markets_ru.py (0 KB)
----- begin content -----
"""
–°–ª–æ–≤–∞—Ä—å –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –∫–æ–¥–æ–≤ API-Football ‚Üí —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º.
"""

from __future__ import annotations

# –±–∞–∑–æ–≤—ã–µ —Ä—ã–Ω–∫–∏ --------------------------------------------------------

MATCH_WINNER = {
    "Home": "–•–æ–∑—è–µ–≤",
    "Draw": "–ù–∏—á—å—è",
    "Away": "–ì–æ—Å—Ç–∏",
}

OVER_UNDER_PICK = {
    "Over": "–ë–æ–ª—å—à–µ",
    "Under": "–ú–µ–Ω—å—à–µ",
}

# –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ —Ñ–æ—Ä–º–∏—Ä—É–µ–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è ------------------------------------

def ru_total(line: float, side: str) -> str:
    return f"–¢–æ—Ç–∞–ª {OVER_UNDER_PICK[side]} {line:.1f}"

def ru_ah(line: float, side: str) -> str:
    sign = "‚àí" if side == "Home" else "+"
    team = "—Ö–æ–∑—è–µ–≤" if side == "Home" else "–≥–æ—Å—Ç–µ–π"
    return f"–§–æ—Ä–∞ ({sign}{abs(line):.1f}) {team}"
-----  end content  -----

[FILE] betai\models.py (1 KB)
----- begin content -----
# betai/models.py

"""
–§–æ—Ä–º—É–ª—ã Edge, Kelly, –º–∞—Å—à—Ç–∞–± '5% √ó N', –ª–∏–º–∏—Ç—ã ‚â§10% / –º–∞—Ç—á‚â§30%.
"""

from __future__ import annotations
from typing import List
from pydantic import BaseModel, Field

EDGE_MIN = 0.05
BANK_PORTFOLIO = 0.05      # 5 % –Ω–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—å

class Outcome(BaseModel):
    fixture_id: int
    date: str      # ISO 8601 MSK
    time: str      # HH:MM MSK
    league: str
    match: str
    market: str
    pick_ru: str
    line: float | None
    k_dec: float
    p_model: float
    flag_url: str = ""         # URL —Ñ–ª–∞–≥–∞ –∏–ª–∏ –ª–æ–≥–æ—Ç–∏–ø–∞ –ª–∏–≥–∏

    # —Ä–∞—Å—á—ë—Ç–Ω—ã–µ –ø–æ–ª—è
    edge: float = Field(0, ge=-1)
    f_raw: float = 0
    f_final: float = 0
    stake_eur: float = 0

    def compute_edge(self) -> None:
        p_book = 1 / self.k_dec
        self.edge = self.p_model / p_book - 1
        if self.edge > 0:
            self.f_raw = self.edge / (self.k_dec - 1)
        else:
            self.f_raw = 0


def allocate_bank(outs: List[Outcome], bank: float) -> None:
    """–º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º Kelly –ø–æ–¥ —Ñ–∏–∫—Å-total-risk –∏ –ª–∏–º–∏—Ç—ã."""
    value_outs = [o for o in outs if o.f_raw > 0]
    if not value_outs:
        return
    F_target = BANK_PORTFOLIO * len(value_outs)
    F_raw_sum = sum(o.f_raw for o in value_outs)
    scale = F_target / F_raw_sum if F_raw_sum else 0

    for o in value_outs:
        o.f_final = min(o.f_raw * scale, 0.10)  # –Ω–µ –±–æ–ª—å—à–µ 10% –Ω–∞ –∏—Å—Ö–æ–¥

    # –ª–∏–º–∏—Ç 30% –Ω–∞ –º–∞—Ç—á
    by_fixture = {}
    for o in value_outs:
        by_fixture.setdefault(o.fixture_id, []).append(o)
    for fixture_outs in by_fixture.values():
        total = sum(o.f_final for o in fixture_outs)
        if total > 0.30:
            k = 0.30 / total
            for o in fixture_outs:
                o.f_final *= k

    # –∏—Ç–æ–≥–æ–≤—ã–µ ‚Ç¨
    for o in value_outs:
        o.stake_eur = round(bank * o.f_final, 2)

-----  end content  -----

[FILE] betai\odds_parser.py (1 KB)
----- begin content -----
from __future__ import annotations
from typing import Dict, List
from .markets_ru import MATCH_WINNER, ru_total, ru_ah

def parse_odds(data: Dict) -> List[Dict]:
    res: List[Dict] = []
    bk = data["response"][0]["bookmakers"] if data["response"] else []
    if not bk:
        return res

    for bet in bk[0]["bets"]:
        name = bet["name"]

        if name == "Match Winner":
            for v in bet["values"]:
                side = v["value"]  # Home / Draw / Away
                res.append(
                    dict(
                        market="1X2",
                        pick_ru=MATCH_WINNER[side],
                        line=None,
                        side=side,
                        k_dec=float(v["odd"]),
                    )
                )

        elif name == "Goals":
            for v in bet["values"]:
                side, line = v["value"].split(" ")
                res.append(
                    dict(
                        market="Total",
                        pick_ru=ru_total(float(line), side),
                        line=float(line),
                        side=side,
                        k_dec=float(v["odd"]),
                    )
                )

        elif name == "Asian Handicap":
            for v in bet["values"]:
                side, raw_line = v["value"].split(" ")
                res.append(
                    dict(
                        market="AH",
                        pick_ru=ru_ah(float(raw_line), side),
                        line=float(raw_line),
                        side=side,
                        k_dec=float(v["odd"]),
                    )
                )
    return res

-----  end content  -----

[FILE] betai\pipelines.py (3 KB)
----- begin content -----
# betai/pipelines.py

"""
–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö: fixtures ‚Üí odds+predictions ‚Üí Outcome[].
"""

from __future__ import annotations
from datetime import datetime, timedelta, timezone
from typing import List
import pytz
from tqdm import tqdm

from .api import get_fixtures, get_odds, get_predictions
from .odds_parser import parse_odds
from .pred_parser import parse_predictions
from .models import Outcome, allocate_bank

MSK = pytz.timezone("Europe/Moscow")

# –¢–∞–±–ª–∏—Ü–∞ –¢–û–ü-30 –ª–∏–≥ (–ø–æ —Ä–µ–π—Ç–∏–Ω–≥—É API-Football)
LEAGUE_RANKING = [
    39, 140, 135, 78, 61,
    2, 3, 848, 94, 88,
    203, 78, 253, 262, 71,
    179, 180, 3, 848, 268,
    322, 571, 129, 63,
    384, 301, 98, 81,
]

def scan_days(days: int, edge_min: float, top_n: int) -> List[Outcome]:
    today_utc = datetime.now(timezone.utc).date()
    outcomes: List[Outcome] = []

    allowed_leagues = set(LEAGUE_RANKING[:top_n])
    now_plus = datetime.now(timezone.utc) + timedelta(minutes=5)

    for d in range(days):
        day = today_utc + timedelta(days=d)
        fixtures = get_fixtures(day).get("response", [])

        for f in tqdm(fixtures, desc=f"{day} fixtures", leave=False):
            lid = f["league"]["id"]
            if lid not in allowed_leagues:
                continue

            # —Ç–æ–ª—å–∫–æ –±—É–¥—É—â–∏–µ –º–∞—Ç—á–∏
            dt_utc = datetime.fromtimestamp(f["fixture"]["timestamp"], tz=timezone.utc)
            if dt_utc <= now_plus:
                continue

            fixture_id = f["fixture"]["id"]
            odds_json = get_odds(fixture_id)
            preds_json = get_predictions(fixture_id)
            preds = parse_predictions(preds_json)

            dt_msk = dt_utc.astimezone(MSK)

            flag = f["league"].get("flag") or f["league"].get("logo", "")

            for o in parse_odds(odds_json):
                # –¥–æ—Å—Ç–∞—ë–º p_model
                if o["market"] in ("Total", "AH"):
                    p_model = preds.get(o["market"], {}).get(o["line"], {}).get(o["side"])
                else:
                    p_model = preds.get("1X2", {}).get(o["side"])

                if p_model is None:
                    continue

                out = Outcome(
                    fixture_id=fixture_id,
                    date=dt_msk.strftime("%Y-%m-%d"),
                    time=dt_msk.strftime("%H:%M"),
                    league=f["league"]["name"],
                    match=f["teams"]["home"]["name"] + " ‚Äì " + f["teams"]["away"]["name"],
                    market=o["market"],
                    pick_ru=o["pick_ru"],
                    line=o["line"],
                    k_dec=o["k_dec"],
                    p_model=p_model,
                    flag_url=flag,
                )
                out.compute_edge()
                if out.edge >= edge_min:
                    outcomes.append(out)
    return outcomes

def full_pipeline(days: int, edge_min: float, bank: float, top_n: int) -> List[Outcome]:
    outs = scan_days(days, edge_min, top_n)
    allocate_bank(outs, bank)
    outs = [o for o in outs if o.stake_eur > 0]
    outs.sort(key=lambda x: (-x.edge, x.date, x.time))
    return outs

-----  end content  -----

[FILE] betai\pred_parser.py (1 KB)
----- begin content -----
# betai/pred_parser.py

"""
–ü–∞—Ä—Å–∏–Ω–≥ /predictions ‚Äì –¥–æ—Å—Ç–∞—ë–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –º–æ–¥–µ–ª–∏ –¥–ª—è 1X2,
–æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ –ø–æ–ª–µ predictions.percent –∏–∑ API-Football.
"""

from __future__ import annotations
from typing import Dict

def parse_predictions(data: Dict) -> Dict:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å –≤–∏–¥–∞:
    {
      '1X2': {'Home': 0.50, 'Draw': 0.50, 'Away': 0.00},
      'Total': {},  # –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –≤ —ç—Ç–æ–º —ç–Ω–¥–ø–æ–∏–Ω—Ç–µ
      'AH': {},     # –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –≤ —ç—Ç–æ–º —ç–Ω–¥–ø–æ–∏–Ω—Ç–µ
    }
    """
    resp = data.get("response")
    if not resp:
        return {"1X2": {}, "Total": {}, "AH": {}}

    pr = resp[0].get("predictions", {})
    pct = pr.get("percent", {})

    # percent —Ö—Ä–∞–Ω–∏—Ç —Å—Ç—Ä–æ–∫–∏ –≤—Ä–æ–¥–µ "50%", "0%", "25%"
    try:
        home = float(pct.get("home", "0%").strip("%")) / 100
        draw = float(pct.get("draw", "0%").strip("%")) / 100
        away = float(pct.get("away", "0%").strip("%")) / 100
    except Exception:
        home = draw = away = 0.0

    return {
        "1X2": {"Home": home, "Draw": draw, "Away": away},
        "Total": {},  # –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞
        "AH": {},     # –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞
    }

-----  end content  -----

[FILE] inspect_preds.py (1 KB)
----- begin content -----
# inspect_preds.py
import os
import json
from datetime import datetime, timezone
from dotenv import load_dotenv

# –≤–∞—à –º–æ–¥—É–ª—å API
from betai.api import get_fixtures, get_predictions

# –∑–∞–≥—Ä—É–∂–∞–µ–º .env
load_dotenv()

def main():
    # 1) –£–∫–∞–∂–∏—Ç–µ –¥–∞—Ç—É, –∑–∞ –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏–º –≥–ª—è–Ω—É—Ç—å –ø–µ—Ä–≤—ã–π –º–∞—Ç—á
    #    –§–æ—Ä–º–∞—Ç YYYY, M, D ‚Äî —Å–µ–≥–æ–¥–Ω—è:
    today = datetime.now(timezone.utc).date()
    
    # 2) –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
    fixtures = get_fixtures(today)["response"]
    if not fixtures:
        print("‚ùå –ù–µ—Ç –º–∞—Ç—á–µ–π –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –≤ —Ç–æ–ø-–ª–∏–≥–∞—Ö.")
        return
    
    # 3) –ò–∑–±–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π –ø–æ–ø–∞–≤—à–∏–π—Å—è –º–∞—Ç—á –∏–∑ —Ç–æ–ø-–ª–∏–≥ (ID –∏–∑ TOP_LEAGUES)
    #    –ó–¥–µ—Å—å —Ç—Ä—É–¥–Ω–æ –∑–Ω–∞—Ç—å –∑–∞—Ä–∞–Ω–µ–µ, –∫–∞–∫–∏–µ –ª–∏–≥–∏ –ø—Ä–∏–¥—É—Ç, –ø–æ—ç—Ç–æ–º—É –ø—Ä–æ—Å—Ç–æ –±–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π:
    fx = fixtures[0]
    fixture_id = fx["fixture"]["id"]
    print(f"–£ inspect_preds.py –ø–µ—Ä–≤—ã–π –º–∞—Ç—á fixture_id = {fixture_id}")
    
    # 4) –ó–∞–±–∏—Ä–∞–µ–º predictions
    preds = get_predictions(fixture_id)
    
    # 5) –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª / –ø–µ—á–∞—Ç–∞–µ–º –≤ –∫–æ–Ω—Å–æ–ª—å –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ
    print(json.dumps(preds, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    main()

-----  end content  -----

[FILE] requirements.txt (0 KB)
----- begin content -----
streamlit>=1.34
pandas>=2.2
requests>=2.32
python-dotenv>=1.0
pydantic>=2.7
sqlitedict>=2.1
tqdm>=4.66          # –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä –≤ —Ç–µ—Ä-–ª–æ–≥–µ
-----  end content  -----

[FILE] snapshot.py (3 KB)
----- begin content -----
#!/usr/bin/env python3
"""
–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç–∞ –ø—Ä–æ–µ–∫—Ç–∞.
–ò—Å–∫–ª—é—á–∞–µ—Ç –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –∏ –±–æ–ª—å—à–∏–µ —Ñ–∞–π–ª—ã (–≤–∫–ª—é—á–∞—è JSON-–¥–∞–º–ø—ã).
"""

from pathlib import Path
from datetime import datetime

# === –ù–∞—Å—Ç—Ä–æ–π–∫–∞ ===
PROJECT_DIR   = Path(r"C:\Code Projects\Bet_AI_pythone")  # –≤–∞—à –ø—Ä–æ–µ–∫—Ç
SNAP_DIR      = PROJECT_DIR / "snapshots"
MAX_SNAPS     = 5
MAX_INLINE_KB = 200  # –ø–æ—Ä–æ–≥ –¥–ª—è –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ

# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ —Ñ–∞–π–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –Ω—É–∂–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å
EXCLUDE_DIRS   = {".venv", "snapshots", "__pycache__", ".git", ".streamlit"}
EXCLUDE_NAMES  = {".env", "secrets.toml"}

# –†–∞—Å—à–∏—Ä–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ —Å—á–∏—Ç–∞—é—Ç—Å—è ¬´–±–∏–Ω–∞—Ä–Ω—ã–º–∏¬ª –∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–ø—É—Å–∫–∞—é—Ç—Å—è
BINARY_EXTS = {
    ".sqlite", ".db", ".log",
    ".png", ".jpg", ".jpeg", ".gif",
    ".bin", ".exe", ".pkl",
    ".json"    # —Ç–µ–ø–µ—Ä—å –∏—Å–∫–ª—é—á–∞–µ–º –∏ JSON-—Ñ–∞–π–ª—ã
}

# –°–æ–∑–¥–∞–¥–∏–º –ø–∞–ø–∫—É –¥–ª—è —Å–Ω–∞–ø—à–æ—Ç–æ–≤, –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
SNAP_DIR.mkdir(exist_ok=True)

# –ò–º—è –Ω–æ–≤–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç–∞
timestamp     = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
snapshot_file = SNAP_DIR / f"snapshot_{timestamp}.txt"


def should_skip(path: Path) -> bool:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–π –ø—É—Ç—å –Ω—É–∂–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å.
    """
    # –ø–æ —á–∞—Å—Ç–∏ –ø—É—Ç–∏ (–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è)
    if any(part in EXCLUDE_DIRS for part in path.parts):
        return True
    # –ø–æ —Ç–æ—á–Ω–æ–º—É –∏–º–µ–Ω–∏
    if path.name in EXCLUDE_NAMES:
        return True
    # –ø–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é
    if path.suffix.lower() in BINARY_EXTS:
        return True
    return False


def create_snapshot():
    with snapshot_file.open("w", encoding="utf-8") as out:
        out.write(f"=== Snapshot of {PROJECT_DIR} at {datetime.now()} ===\n\n")

        for p in sorted(PROJECT_DIR.rglob("*")):
            rel = p.relative_to(PROJECT_DIR)
            if should_skip(p):
                continue

            if p.is_dir():
                out.write(f"[DIR ] {rel}\n")
            else:
                size_kb = p.stat().st_size // 1024
                out.write(f"[FILE] {rel} ({size_kb} KB)\n")

                # –ï—Å–ª–∏ —Ñ–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ‚Äî –Ω–µ –≤—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
                if size_kb > MAX_INLINE_KB:
                    out.write(f"  # skipped content ({size_kb} KB > {MAX_INLINE_KB} KB)\n\n")
                    continue

                # –í—Å—Ç—Ä–æ–∏–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª
                try:
                    text = p.read_text(encoding="utf-8", errors="replace")
                except Exception as e:
                    out.write(f"  # unable to read file: {e}\n\n")
                    continue

                out.write("----- begin content -----\n")
                out.write(text)
                out.write("\n-----  end content  -----\n\n")

        out.write("=== End of snapshot ===\n")

    print(f"‚úÖ Snapshot saved to: {snapshot_file}")


def prune_old_snapshots():
    snaps = sorted(
        SNAP_DIR.glob("snapshot_*.txt"),
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )
    for old in snaps[MAX_SNAPS:]:
        try:
            old.unlink()
            print(f"üóë Removed old snapshot: {old.name}")
        except Exception:
            pass


if __name__ == "__main__":
    create_snapshot()
    prune_old_snapshots()

-----  end content  -----

[DIR ] tests
[FILE] tests\test_kelly.py (0 KB)
----- begin content -----
from betai.models import Outcome, allocate_bank

def test_kelly_example():
    bank = 1000
    outs = [
        Outcome(fixture_id=1, date="", time="", league="", match="",
                market="1X2", pick_ru="", line=None,
                k_dec=2.10, p_model=0.540),
        Outcome(fixture_id=2, date="", time="", league="", match="",
                market="1X2", pick_ru="", line=None,
                k_dec=1.95, p_model=0.560),
        Outcome(fixture_id=3, date="", time="", league="", match="",
                market="1X2", pick_ru="", line=None,
                k_dec=3.60, p_model=0.310),
    ]
    for o in outs:
        o.compute_edge()
    allocate_bank(outs, bank)
    stakes = [o.stake_eur for o in outs]
    assert sum(stakes) == 150      # 15 % –±–∞–Ω–∫–∞

-----  end content  -----

=== End of snapshot ===
