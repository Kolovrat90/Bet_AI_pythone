=== Snapshot of C:\Code Projects\Bet_AI_pythone at 2025-05-20 14:30:45.197657 ===

[DIR ] .pytest_cache
[FILE] .pytest_cache\.gitignore (0 KB)
----- begin content -----
# Created by pytest automatically.
*

-----  end content  -----

[FILE] .pytest_cache\CACHEDIR.TAG (0 KB)
----- begin content -----
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html

-----  end content  -----

[FILE] .pytest_cache\README.md (0 KB)
----- begin content -----
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

-----  end content  -----

[DIR ] .pytest_cache\v
[DIR ] .pytest_cache\v\cache
[FILE] .pytest_cache\v\cache\lastfailed (0 KB)
----- begin content -----
{
  "tests/test_kelly.py::test_kelly_example": true
}
-----  end content  -----

[FILE] .pytest_cache\v\cache\nodeids (0 KB)
----- begin content -----
[
  "tests/test_kelly.py::test_kelly_example",
  "tests/test_pipelines.py::test_detailed_analysis_integration",
  "tests/test_pipelines.py::test_elo_cache",
  "tests/test_pipelines.py::test_quick_prob_elo_difference",
  "tests/test_pipelines.py::test_quick_prob_symmetry",
  "tests/test_pipelines.py::test_quick_screen_filters",
  "tests/test_pipelines.py::test_value_approx"
]
-----  end content  -----

[FILE] .pytest_cache\v\cache\stepwise (0 KB)
----- begin content -----
[]
-----  end content  -----

[FILE] app.py (6 KB)
----- begin content -----
import os
from datetime import datetime, date, time as dt_time
import streamlit as st
import pandas as pd

from betai.pipelines import scan_days
from betai.models import allocate_bank

# ‚îÄ‚îÄ Page config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
st.set_page_config(page_title="BetAI ‚Äì Value Betting Scanner", page_icon="‚öΩ", layout="wide")
st.markdown("# ‚öΩ BetAI ‚Äì Value Betting Scanner (MVP)")

# ‚îÄ‚îÄ API-–∫–ª—é—á ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
API_KEY = st.secrets.get("APIFOOTBALL_KEY") or os.getenv("APIFOOTBALL_KEY")
if not API_KEY:
    st.error("–ù—É–∂–µ–Ω –∫–ª—é—á APIFOOTBALL_KEY –≤ .streamlit/secrets.toml –∏–ª–∏ –∫–∞–∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
    st.stop()

# ‚îÄ‚îÄ Inputs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
c0, c1, c2 = st.columns([1, 2, 2])
with c0:
    today_only = st.checkbox("–°–µ–≥–æ–¥–Ω—è", True)
with c1:
    edge_pct = st.slider("–ü–æ—Ä–æ–≥ —Ü–µ–Ω–Ω–æ—Å—Ç–∏, %", 1, 10, 5)
with c2:
    bank = st.number_input("–ë–∞–Ω–∫, ‚Ç¨", min_value=10.0, step=50.0, value=1000.0, format="%.2f")

days = 1 if today_only else st.selectbox("–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –¥–Ω–µ–π –≤–ø–µ—Ä—ë–¥", [1, 2, 3], 0)
top_n = st.selectbox("–¢–æ–ø-–ª–∏–≥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞", [10, 15, 20, 25, 30], 0)

btn_scan = st.button("üîç –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—á–∏", type="primary")
btn_calc = st.button("üí∞ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–∞–≤–∫–∏")

# ‚îÄ‚îÄ Cached scan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@st.cache_data(show_spinner=False)
def _scan(d, e, n):
    return scan_days(d, e, n)

# ‚îÄ‚îÄ –®–∞–≥ 1: —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if btn_scan:
    outs = _scan(days, edge_pct / 100.0, top_n)
    st.session_state["outs_raw"] = outs
    st.success(f"–ù–∞–π–¥–µ–Ω–æ {len(outs)} value-–∏—Å—Ö–æ–¥–æ–≤ (edge ‚â• {edge_pct}%)")

# ‚îÄ‚îÄ –®–∞–≥ 2: —Ä–µ–¥–∞–∫—Ç–æ—Ä –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if "outs_raw" in st.session_state:
    outs = st.session_state["outs_raw"]

    # –°–æ–±–∏—Ä–∞–µ–º DataFrame –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —É–∂–µ —Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏
    df = pd.DataFrame(o.model_dump() for o in outs)
    now = datetime.now()
    df = df[df.apply(
        lambda r: datetime.combine(date.fromisoformat(r.date),
                                   dt_time.fromisoformat(r.time)) > now,
        axis=1
    )].reset_index(drop=True)

    # –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–∫—É ‚Ññ, Use, —Å–ª—É–∂–µ–±–Ω—ã–µ –ø–æ–ª—è
    df.insert(0, "No", range(1, len(df) + 1))
    df.insert(1, "Use", True)
    df["Edge %"] = (df["edge"] * 100).round(1)
    df["Stake ‚Ç¨"] = 0
    df["Flag"] = df["flag_url"]
    df = df.rename(columns={
        "date":    "Date", "time":    "Time",
        "league":  "League", "match":  "Match",
        "pick_ru": "Pick",   "k_dec":   "Min Odds"
    })
    view = df[["No", "Use", "Date", "Time", "Flag", "League", "Match", "Pick", "Min Odds", "Edge %", "Stake ‚Ç¨"]]

    # –ü–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã: –æ–¥–∏–Ω –¥–ª—è –º–µ—Ç—Ä–∏–∫, –≤—Ç–æ—Ä–æ–π –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã (—Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞)
    metrics_ph = st.empty()
    table_ph   = st.empty()

    # –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º—ã–π DataFrame
    edited = table_ph.data_editor(
        view,
        hide_index=True,
        column_config={
            "No":      st.column_config.NumberColumn("‚Ññ", format="%d", disabled=True),
            "Use":     st.column_config.CheckboxColumn(),
            "Flag":    st.column_config.ImageColumn("", width="small"),
            "Edge %":  st.column_config.NumberColumn(format="%.1f %"),
            "Stake ‚Ç¨": st.column_config.NumberColumn(format="%d"),
        },
        use_container_width=True,
    )

    # –ü–æ –Ω–∞–∂–∞—Ç–∏—é ¬´–†–∞—Å—Å—á–∏—Ç–∞—Ç—å¬ª ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏ –Ω–∞–¥ —Ç–∞–±–ª–∏—Ü–µ–π –∏ —Å–∞–º—É —Ç–∞–±–ª–∏—Ü—É
    if btn_calc:
        mask = edited["Use"].tolist()
        kept = [o for o, u in zip(outs, mask) if u]

        if not kept:
            st.warning("–ù–µ—á–µ–≥–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—Ç—å ‚Äî –Ω–∏ –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ –Ω–µ –æ—Ç–º–µ—á–µ–Ω–∞.")
        else:
            # –ê–ª–ª–æ–∫–∞—Ü–∏—è –±–∞–Ω–∫–∞
            allocate_bank(kept, bank)

            # –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–π DataFrame —Å –Ω—É–º–µ—Ä–∞—Ü–∏–µ–π
            rows = []
            for o in kept:
                rows.append({
                    "Date":     o.date,
                    "Time":     o.time,
                    "Flag":     o.flag_url,
                    "League":   o.league,
                    "Match":    o.match,
                    "Pick":     o.pick_ru.replace("–ü–æ–±–µ–¥–∞ —Ö–æ–∑—è–µ–≤", "–•–æ–∑—è–µ–≤–∞")
                                      .replace("–ü–æ–±–µ–¥–∞ –≥–æ—Å—Ç–µ–π", "–ì–æ—Å—Ç–∏"),
                    "Min Odds": o.k_dec,
                    "Edge %":   f"{o.edge*100:.1f} %",
                    "Stake ‚Ç¨":  int(round(o.stake_eur))
                })
            res_df = pd.DataFrame(rows)
            res_df.insert(0, "No", range(1, len(res_df) + 1))

            # –ú–µ—Ç—Ä–∏–∫–∏ –Ω–∞–¥ —Ç–∞–±–ª–∏—Ü–µ–π, –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ø–æ–¥ –Ω—É–∂–Ω—ã–º–∏ —Å—Ç–æ–ª–±—Ü–∞–º–∏
            n_cols = len(res_df.columns)
            cols = metrics_ph.columns(n_cols)
            idx_min = res_df.columns.get_loc("Min Odds")
            idx_edge = res_df.columns.get_loc("Edge %")
            idx_stk  = res_df.columns.get_loc("Stake ‚Ç¨")
            cols[idx_min].metric("‚åÄ Min Odds", f"{res_df['Min Odds'].mean():.2f}")
            avg_edge = res_df["Edge %"].str.rstrip(" %").astype(float).mean()
            cols[idx_edge].metric("‚åÄ Edge %", f"{avg_edge:.1f} %")
            cols[idx_stk].metric("Œ£ Stake ‚Ç¨", f"{res_df['Stake ‚Ç¨'].sum()}")

            # –ò —Å–∞–º –∏—Ç–æ–≥–æ–≤—ã–π DataFrame –≤–º–µ—Å—Ç–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
            table_ph.dataframe(
                res_df,
                hide_index=True,
                use_container_width=True,
                column_config={
                    "Flag":    st.column_config.ImageColumn("", width="small"),
                    "Stake ‚Ç¨": st.column_config.NumberColumn(format="%d"),
                },
            )

-----  end content  -----

[DIR ] betai
[FILE] betai\__init__.py (0 KB)
----- begin content -----
# –ø—É—Å—Ç–æ–π: –ø—Ä–æ—Å—Ç–æ –ø–æ–º–µ—á–∞–µ—Ç –∫–∞—Ç–∞–ª–æ–≥ –∫–∞–∫ –ø–∞–∫–µ—Ç

-----  end content  -----

[FILE] betai\api.py (4 KB)
----- begin content -----
"""
–¢–æ–Ω–∫–∞—è –æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ API-Football v3 + —Ñ–∞–π–ª-–∫–µ—à SQLite.
"""

from __future__ import annotations
import os
import time
import sqlite3
from datetime import datetime, timedelta, timezone
from typing import Any, Dict

import requests
from dotenv import load_dotenv
from sqlitedict import SqliteDict

# ---------------------------------------------------------------------
# –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

ROOT = os.path.dirname(os.path.abspath(__file__))
CACHE_FILE = os.path.join(ROOT, "apifootball_cache.sqlite")

load_dotenv()
API_KEY = os.getenv("APIFOOTBALL_KEY")
if not API_KEY:
    raise RuntimeError("API key is required ‚Äì create .env with APIFOOTBALL_KEY=...")

BASE_URL = "https://v3.football.api-sports.io"
HEADERS = {"x-apisports-key": API_KEY}

# TTL –∫–µ—à–∞ (—Å–µ–∫) –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
TTL = {
    "fixtures":    6 * 3600,      # —Ñ–∏–∫—Å—Ç—É—Ä—ã –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è —Ä–∞–∑ –≤ 6 —á
    "odds":        6 * 3600,
    "predictions": 6 * 3600,
}

# ---------------------------------------------------------------------
# –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –¥–æ—Å—Ç—É–ø –∫ –∫–µ—à—É HTTP-–æ—Ç–≤–µ—Ç–æ–≤

_cache = SqliteDict(CACHE_FILE, autocommit=True)


def _cache_key(path: str, params: Dict[str, Any]) -> str:
    return f"{path}:" + "&".join(f"{k}={v}" for k, v in sorted(params.items()))


def _get(path: str, params: Dict[str, Any], ttl: int) -> Any:
    key = _cache_key(path, params)
    now = time.time()
    if key in _cache:
        ts, data = _cache[key]
        if now - ts < ttl:
            return data
    resp = requests.get(f"{BASE_URL}/{path}", headers=HEADERS, params=params, timeout=20)
    resp.raise_for_status()
    data = resp.json()
    _cache[key] = (now, data)
    return data


# ---------------------------------------------------------------------
# –ø—É–±–ª–∏—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ API-Football

def get_fixtures(date: datetime) -> Dict[str, Any]:
    """–§–∏–∫—Å—Ç—É—Ä—ã –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—É—é –¥–∞—Ç—É (UTC)."""
    return _get(
        "fixtures",
        {"date": date.strftime("%Y-%m-%d"), "timezone": "UTC"},
        TTL["fixtures"],
    )


def get_odds(fixture_id: int) -> Dict[str, Any]:
    """–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –º–∞—Ç—á–∞."""
    return _get(
        "odds",
        {"fixture": fixture_id},
        TTL["odds"],
    )


def get_predictions(fixture_id: int) -> Dict[str, Any]:
    """Predictions-—ç–Ω–¥–ø–æ–∏–Ω—Ç API-Football."""
    return _get(
        "predictions",
        {"fixture": fixture_id},
        TTL["predictions"],
    )


# ---------------------------------------------------------------------
# Fast-Screen: –∫—ç—à Elo –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ñ–æ—Ä–º—ã –∫–æ–º–∞–Ω–¥—ã

# –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º SQLite –¥–ª—è –∫—ç—à–∞ Elo
DB_PATH = os.getenv("BETAI_DB", os.path.join(ROOT, "betai_cache.db"))
_conn = sqlite3.connect(DB_PATH, check_same_thread=False)
_cur = _conn.cursor()
_cur.execute("""
CREATE TABLE IF NOT EXISTS elo_daily (
    date TEXT,
    team_id INTEGER,
    elo REAL,
    PRIMARY KEY (date, team_id)
)
""")
_conn.commit()


def get_team_form(team_id: int, last_n: int = 10) -> list[dict[str, Any]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö N –º–∞—Ç—á–µ–π –∫–æ–º–∞–Ω–¥—ã —Å –±–∞–∑–æ–≤—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏,
    —á—Ç–æ–±—ã –æ—Ü–µ–Ω–∏—Ç—å data_completeness.
    """
    data = _get(
        "fixtures",
        {"team": team_id, "last": last_n, "timezone": "UTC"},
        TTL["fixtures"],
    ).get("response", [])
    return data


def load_elo(team_id: int, date_str: str) -> float | None:
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–∑ –∫—ç—à–∞ Elo –∫–æ–º–∞–Ω–¥—ã –Ω–∞ –∑–∞–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É (YYYY-MM-DD).
    """
    _cur.execute(
        "SELECT elo FROM elo_daily WHERE team_id = ? AND date = ?",
        (team_id, date_str),
    )
    row = _cur.fetchone()
    return row[0] if row else None


def save_elo(team_id: int, date_str: str, elo: float) -> None:
    """
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç/–æ–±–Ω–æ–≤–ª—è–µ—Ç Elo –∫–æ–º–∞–Ω–¥—ã –Ω–∞ –∑–∞–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É –≤ –∫—ç—à–µ.
    """
    _cur.execute(
        "REPLACE INTO elo_daily (date, team_id, elo) VALUES (?, ?, ?)",
        (date_str, team_id, elo),
    )
    _conn.commit()

-----  end content  -----

[FILE] betai\constants.py (0 KB)
----- begin content -----
"""Static constants: league white‚Äëlist, markets, etc."""

# Top‚Äë10 –µ–≤—Ä–æ–ø–µ–π—Å–∫–∏—Ö –¥–∏–≤–∏–∑–∏–æ–Ω–æ–≤ (id API‚ÄëFootball v3)
TOP_LEAGUES = {
    39,   # EPL –ê–Ω–≥–ª–∏—è
    140,  # –õ–∞ –õ–∏–≥–∞ –ò—Å–ø–∞–Ω–∏—è
    135,  # –°–µ—Ä–∏—è¬†A –ò—Ç–∞–ª–∏—è
    78,   # –ë—É–Ω–¥–µ—Å–ª–∏–≥–∞ –ì–µ—Ä–º–∞–Ω–∏—è
    61,   # –õ–∏–≥–∞¬†1 –§—Ä–∞–Ω—Ü–∏—è
    88,   # –≠—Ä–µ–¥–∏–≤–∏–∑–∏ –ù–∏–¥–µ—Ä–ª–∞–Ω–¥—ã
    94,   # –ü—Ä–∏–º–µ–π—Ä–∞¬†–ü–æ—Ä—Ç—É–≥–∞–ª–∏—è
    253,  # –ü—Ä–µ–º—å–µ—Ä‚Äë–ª–∏–≥–∞ –†–æ—Å—Å–∏—è
    203,  # –ë–µ–ª—å–≥–∏—è Jupiler
    2,    # –õ–∏–≥–∞ –ß–µ–º–ø–∏–æ–Ω–æ–≤ UEFA ‚Äì –≤—ã–Ω–µ—Å–µ–Ω –∫–∞–∫ –º–∞—Ä–∫–µ—Ä —Ç–æ–ø‚Äë—É—Ä–æ–≤–Ω—è
}

EDGE_DEFAULT = 0.05  # 5¬†%
-----  end content  -----

[FILE] betai\markets_ru.py (0 KB)
----- begin content -----
"""
–°–ª–æ–≤–∞—Ä—å –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –∫–æ–¥–æ–≤ API-Football ‚Üí —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º.
"""

from __future__ import annotations

# –±–∞–∑–æ–≤—ã–µ —Ä—ã–Ω–∫–∏ --------------------------------------------------------

MATCH_WINNER = {
    "Home": "–•–æ–∑—è–µ–≤",
    "Draw": "–ù–∏—á—å—è",
    "Away": "–ì–æ—Å—Ç–∏",
}

OVER_UNDER_PICK = {
    "Over": "–ë–æ–ª—å—à–µ",
    "Under": "–ú–µ–Ω—å—à–µ",
}

# –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ —Ñ–æ—Ä–º–∏—Ä—É–µ–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è ------------------------------------

def ru_total(line: float, side: str) -> str:
    return f"–¢–æ—Ç–∞–ª {OVER_UNDER_PICK[side]} {line:.1f}"

def ru_ah(line: float, side: str) -> str:
    sign = "‚àí" if side == "Home" else "+"
    team = "—Ö–æ–∑—è–µ–≤" if side == "Home" else "–≥–æ—Å—Ç–µ–π"
    return f"–§–æ—Ä–∞ ({sign}{abs(line):.1f}) {team}"
-----  end content  -----

[FILE] betai\models.py (4 KB)
----- begin content -----
"""
–§–æ—Ä–º—É–ª—ã Edge, Kelly, –º–∞—Å—à—Ç–∞–± '5% √ó N', –ª–∏–º–∏—Ç—ã ‚â§10% / –º–∞—Ç—á‚â§30%,
–∞ —Ç–∞–∫–∂–µ Fast-Screen: quick_prob, value_approx, –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∏ shrinkage.
"""

from __future__ import annotations
from typing import List
import math

from pydantic import BaseModel, Field

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –±–∞–Ω–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞
EDGE_MIN = 0.05
BANK_PORTFOLIO = 0.05      # 5 % –Ω–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—å

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ shrinkage (–≤–∑–≤–µ—à–∏–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –∏ —Ä—ã–Ω–∫–∞)
SHRINKAGE_ALPHA = 0.7  # –≤–µ—Å –º–æ–¥–µ–ª–∏
SHRINKAGE_BETA = 0.3   # –≤–µ—Å —Ä—ã–Ω–∫–∞


class Outcome(BaseModel):
    fixture_id: int
    date: str      # ISO 8601 MSK
    time: str      # HH:MM MSK
    league: str
    match: str
    market: str
    pick_ru: str
    line: float | None
    k_dec: float
    p_model: float
    flag_url: str = ""         # URL —Ñ–ª–∞–≥–∞ –∏–ª–∏ –ª–æ–≥–æ—Ç–∏–ø–∞ –ª–∏–≥–∏

    # —Ä–∞—Å—á—ë—Ç–Ω—ã–µ –ø–æ–ª—è
    edge: float = Field(0, ge=-1)
    f_raw: float = 0
    f_final: float = 0
    stake_eur: float = 0

    def compute_edge(self) -> None:
        """–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–∞—Å—á—ë—Ç edge –∏ raw Kelly."""
        p_book = 1 / self.k_dec
        self.edge = self.p_model / p_book - 1
        if self.edge > 0:
            self.f_raw = self.edge / (self.k_dec - 1)
        else:
            self.f_raw = 0


def allocate_bank(outs: List[Outcome], bank: float) -> None:
    """–º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º Kelly –ø–æ–¥ —Ñ–∏–∫—Å-total-risk –∏ –ª–∏–º–∏—Ç—ã."""
    value_outs = [o for o in outs if o.f_raw > 0]
    if not value_outs:
        return
    # —Ü–µ–ª—å –ø–æ —Ä–∏—Å–∫—É: 5% –Ω–∞ –∫–∞–∂–¥–æ–µ value
    F_target = BANK_PORTFOLIO * len(value_outs)
    F_raw_sum = sum(o.f_raw for o in value_outs)
    scale = F_target / F_raw_sum if F_raw_sum else 0

    # –ø–µ—Ä–≤—ã–π –ø—Ä–æ—Ö–æ–¥: –ª–∏–º–∏—Ç 10% –Ω–∞ –∏—Å—Ö–æ–¥
    for o in value_outs:
        o.f_final = min(o.f_raw * scale, 0.10)

    # –≤—Ç–æ—Ä–æ–π –ø—Ä–æ—Ö–æ–¥: –ª–∏–º–∏—Ç 30% –Ω–∞ –≤–µ—Å—å –º–∞—Ç—á
    by_fixture: dict[int, List[Outcome]] = {}
    for o in value_outs:
        by_fixture.setdefault(o.fixture_id, []).append(o)
    for fixture_outs in by_fixture.values():
        total = sum(o.f_final for o in fixture_outs)
        if total > 0.30:
            k = 0.30 / total
            for o in fixture_outs:
                o.f_final *= k

    # –∏—Ç–æ–≥–æ–≤—ã–µ —Å—Ç–∞–≤–∫–∏ –≤ ‚Ç¨
    for o in value_outs:
        o.stake_eur = round(bank * o.f_final, 2)


# -----------------------------------------------------------------------------
# Fast-Screen: –±—ã—Å—Ç—Ä—ã–µ –æ—Ü–µ–Ω–∫–∏ p_est –∏ –≥—Ä—É–±—ã–π value

def quick_prob(
    elo_home: float,
    elo_away: float,
    hfa: float = 0.0,
) -> tuple[float, float, float]:
    """
    –ë—ã—Å—Ç—Ä–∞—è –æ—Ü–µ–Ω–∫–∞ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π (–±–µ–∑ Poisson):
      ŒîElo = elo_home + hfa ‚Äì elo_away
      p_home = 1 / (1 + 10^(‚ÄìŒîElo/400))
      p_draw ‚âà 0.24 ¬∑ exp(‚Äì|ŒîElo| / 600)
      p_away = 1 ‚Äì p_home ‚Äì p_draw
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (p_home, p_draw, p_away).
    """
    d_elo = elo_home + hfa - elo_away
    p_home = 1.0 / (1.0 + 10 ** (-d_elo / 400.0))
    p_draw = 0.24 * math.exp(-abs(d_elo) / 600.0)
    # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ —Å—É–º–º–∞ = 1
    p_away = max(0.0, 1.0 - p_home - p_draw)
    return p_home, p_draw, p_away


def value_approx(
    p_est: float,
    k_mean: float
) -> float:
    """
    –ì—Ä—É–±–∞—è –æ—Ü–µ–Ω–∫–∞ value –¥–ª—è —Ä—ã–Ω–∫–∞:
      value_approx = p_est * k_mean
    """
    return p_est * k_mean


# -----------------------------------------------------------------------------
# –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∏ Shrinkage (–º–µ—Å—Ç–æ –¥–ª—è –±—É–¥—É—â–µ–π –¥–æ—Ä–∞–±–æ—Ç–∫–∏)

def calibrate_platt(
    logits: List[float],
    labels: List[int],
) -> tuple[float, float]:
    """
    –ó–∞–¥–∞—á–∞: –æ–±—É—á–∏—Ç—å Platt-—Å–∏–≥–º–æ–∏–¥—É:
      p_cal = 1 / (1 + exp(A¬∑logit + B))
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (A, B).
    –ü–æ–∫–∞ –∑–∞–≥–ª—É—à–∫–∞ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º (1, 0), —Ç–æ –µ—Å—Ç—å p_cal = sigmoid(logit).
    """
    # TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ –Ω–∞ rolling-–æ–∫–Ω–µ
    return 1.0, 0.0


def apply_shrinkage(
    p_model: float,
    k_mean: float
) -> float:
    """
    Shrinkage: –æ–±—ä–µ–¥–∏–Ω—è–µ–º –º–æ–¥–µ–ª—å –∏ —Å—Ä–µ–¥–Ω—é—é –ª–∏–Ω–∏—é —Ä—ã–Ω–∫–∞
      p_market = 1 / k_mean
      p_final = Œ±¬∑p_model + Œ≤¬∑p_market
    """
    p_market = 1.0 / k_mean if k_mean > 0 else 0.0
    return SHRINKAGE_ALPHA * p_model + SHRINKAGE_BETA * p_market

-----  end content  -----

[FILE] betai\odds_parser.py (1 KB)
----- begin content -----
from __future__ import annotations
from typing import Dict, List
from .markets_ru import MATCH_WINNER, ru_total, ru_ah

def parse_odds(data: Dict) -> List[Dict]:
    res: List[Dict] = []
    bk = data["response"][0]["bookmakers"] if data["response"] else []
    if not bk:
        return res

    for bet in bk[0]["bets"]:
        name = bet["name"]

        if name == "Match Winner":
            for v in bet["values"]:
                side = v["value"]  # Home / Draw / Away
                res.append(
                    dict(
                        market="1X2",
                        pick_ru=MATCH_WINNER[side],
                        line=None,
                        side=side,
                        k_dec=float(v["odd"]),
                    )
                )

        elif name == "Goals":
            for v in bet["values"]:
                side, line = v["value"].split(" ")
                res.append(
                    dict(
                        market="Total",
                        pick_ru=ru_total(float(line), side),
                        line=float(line),
                        side=side,
                        k_dec=float(v["odd"]),
                    )
                )

        elif name == "Asian Handicap":
            for v in bet["values"]:
                side, raw_line = v["value"].split(" ")
                res.append(
                    dict(
                        market="AH",
                        pick_ru=ru_ah(float(raw_line), side),
                        line=float(raw_line),
                        side=side,
                        k_dec=float(v["odd"]),
                    )
                )
    return res

-----  end content  -----

[FILE] betai\pipelines.py (7 KB)
----- begin content -----
# betai/pipelines.py

"""
–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö: fixtures ‚Üí Fast-Screen ‚Üí detailed_analysis ‚Üí Outcome[] ‚Üí allocate_bank.
"""

from __future__ import annotations
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any
import pytz
from tqdm import tqdm

from .api import get_fixtures, get_odds, get_predictions, get_team_form, load_elo, save_elo
from .odds_parser import parse_odds
from .pred_parser import parse_predictions
from .models import (
    Outcome,
    allocate_bank,
    quick_prob,
    value_approx,
    apply_shrinkage,
)

MSK = pytz.timezone("Europe/Moscow")

# –¢–∞–±–ª–∏—Ü–∞ –¢–û–ü-–ª–∏–≥ (–ø–æ —Ä–µ–π—Ç–∏–Ω–≥—É API-Football)
LEAGUE_RANKING = [
    39, 140, 135, 78, 61,
    2, 3, 848, 94, 88,
    203, 78, 253, 262, 71,
    179, 180, 3, 848, 268,
    322, 571, 129, 63,
    384, 301, 98, 81,
]


def quick_screen(
    days: int,
    top_n: int,
    completeness_thresh: float = 0.8,
    value_thresh: float = 0.95,
    p_min: float = 0.25,
    p_max: float = 0.75,
    max_events: int = 30,
    hfa: float = 60.0,
) -> List[Dict[str, Any]]:
    """
    Fast-Screen:
    1. –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ª–∏–≥ –∏ –¥–∞—Ç
    2. –ü—Ä–æ–≤–µ—Ä–∫–∞ completeness: —É –∫–∞–∂–¥–æ–π –∫–æ–º–∞–Ω–¥—ã ‚â•10 –º–∞—Ç—á–µ–π, –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç—å ‚â• completeness_thresh
    3. –ë—ã—Å—Ç—Ä—ã–π —Ä–∞—Å—á—ë—Ç p_est –ø–æ Elo –∏ HFA
    4. –ì—Ä—É–±—ã–π value_approx = p_est * k_mean, —Ñ–∏–ª—å—Ç—Ä –ø–æ value_thresh –∏ [p_min, p_max]
    5. –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é value_approx, top max_events
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π —Å –Ω—É–∂–Ω—ã–º–∏ –ø–æ–ª—è–º–∏ –¥–ª—è detailed_analysis.
    """
    today_utc = datetime.now(timezone.utc).date()
    candidates: List[Dict[str, Any]] = []

    allowed_leagues = set(LEAGUE_RANKING[:top_n])
    cutoff = datetime.now(timezone.utc) + timedelta(minutes=5)

    for d in range(days):
        day = today_utc + timedelta(days=d)
        fixtures = get_fixtures(day).get("response", [])

        for f in fixtures:
            lid = f["league"]["id"]
            if lid not in allowed_leagues:
                continue

            ts = datetime.fromtimestamp(f["fixture"]["timestamp"], tz=timezone.utc)
            if ts <= cutoff:
                continue

            home = f["teams"]["home"]["id"]
            away = f["teams"]["away"]["id"]

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º completeness –¥–∞–Ω–Ω—ã—Ö –ø–æ –∫–æ–º–∞–Ω–¥–∞–º
            home_form = get_team_form(home, last_n=10)
            away_form = get_team_form(away, last_n=10)
            if len(home_form) < 10 or len(away_form) < 10:
                continue
            # TODO: –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ª–µ–π ‚â• completeness_thresh

            # –ó–∞–≥—Ä—É–∂–∞–µ–º/–≤—ã—á–∏—Å–ª—è–µ–º Elo –Ω–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É
            date_str = day.isoformat()
            eh = load_elo(home, date_str) or 1500.0
            ea = load_elo(away, date_str) or 1500.0

            # –ë—ã—Å—Ç—Ä—ã–π p_est
            p_h, p_d, p_a = quick_prob(eh, ea, hfa)

            # –°–±–æ—Ä —Å—Ä–µ–¥–Ω–µ–π –ª–∏–Ω–∏–∏ 1X2
            odds = get_odds(f["fixture"]["id"]).get("response", [])
            # –≤–æ–∑—å–º—ë–º —Ç–æ–ª—å–∫–æ —Ä—ã–Ω–æ–∫ Match Winner, –ø–µ—Ä–≤—É—é –∫–Ω–∏–≥—É
            bk = odds[0]["bookmakers"][0]["bets"] if odds and odds[0]["bookmakers"] else []
            k_list = []
            for bet in bk:
                if bet["name"] == "Match Winner":
                    k_list = [float(v["odd"]) for v in bet["values"]]
                    break
            if len(k_list) < 2:
                continue
            k_mean = sum(k_list[:2]) / 2  # Home vs Away

            # –ì—Ä—É–±—ã–π value –¥–ª—è Home –∏ Away (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–∏—á—å—é)
            for side, p_est in (("Home", p_h), ("Away", p_a)):
                val = value_approx(p_est, k_mean)
                if val >= value_thresh and p_min <= p_est <= p_max:
                    candidates.append({
                        **f,
                        "side": side,
                        "p_est": p_est,
                        "k_mean": k_mean,
                        "value_approx": val,
                    })

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –±–µ—Ä—ë–º —Ç–æ–ø
    candidates.sort(key=lambda x: x["value_approx"], reverse=True)
    return candidates[:max_events]


def detailed_analysis(
    candidates: List[Dict[str, Any]],
    edge_min: float,
) -> List[Outcome]:
    """
    –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞:
    1. –ü–∞—Ä—Å–∏–º –ø–æ–ª–Ω—ã–µ odds –∏ predictions
    2. –ü–æ–ª—É—á–∞–µ–º —Ç–æ—á–Ω—ã–π p_model, –ø—Ä–∏–º–µ–Ω—è–µ–º shrinkage
    3. –°–æ–∑–¥–∞—ë–º Outcome, —Å—á–∏—Ç–∞–µ–º edge
    4. –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ edge_min
    """
    outcomes: List[Outcome] = []
    for c in tqdm(candidates, desc="detailed analysis", leave=False):
        fid = c["fixture"]["fixture"]["id"]
        dt_utc = datetime.fromtimestamp(c["fixture"]["timestamp"], tz=timezone.utc)
        dt_msk = dt_utc.astimezone(MSK)

        odds_json = get_odds(fid)
        preds_json = get_predictions(fid)
        preds = parse_predictions(preds_json)

        for o in parse_odds(odds_json):
            # —Ç–æ—á–Ω—ã–π p_model
            pm = (
                preds.get(o["market"], {})
                     .get(o["line"], {})
                     .get(o["side"], None)
            )
            if pm is None:
                continue

            # –ø—Ä–∏–º–µ–Ω—è–µ–º shrinkage
            p_final = apply_shrinkage(pm, c["k_mean"])

            out = Outcome(
                fixture_id=fid,
                date=dt_msk.strftime("%Y-%m-%d"),
                time=dt_msk.strftime("%H:%M"),
                league=c["league"]["name"],
                match=c["teams"]["home"]["name"] + " ‚Äì " + c["teams"]["away"]["name"],
                market=o["market"],
                pick_ru=o["pick_ru"],
                line=o["line"],
                k_dec=o["k_dec"],
                p_model=p_final,
                flag_url=c["league"].get("flag") or c["league"].get("logo", ""),
            )
            out.compute_edge()
            if out.edge >= edge_min:
                outcomes.append(out)

    return outcomes


def scan_days(days: int, edge_min: float, top_n: int) -> List[Outcome]:
    """
    –û–±—ä–µ–¥–∏–Ω—è–µ–º fast-screen –∏ detailed-analysis:
      1) quick_screen ‚Üí –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
      2) detailed_analysis ‚Üí —Ç–æ—á–Ω—ã–µ Outcome
    """
    cand = quick_screen(days, top_n)
    detailed = detailed_analysis(cand, edge_min)
    return detailed


def full_pipeline(
    days: int,
    edge_min: float,
    bank: float,
    top_n: int,
) -> List[Outcome]:
    """
    –ü–æ–ª–Ω—ã–π –∫–æ–Ω–≤–µ–π–µ—Ä: scan_days ‚Üí allocate_bank ‚Üí —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö —Å—Ç–∞–≤–æ–∫.
    """
    outs = scan_days(days, edge_min, top_n)
    allocate_bank(outs, bank)
    # —Ç–æ–ª—å–∫–æ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç–∞–≤–∫–∏
    outs = [o for o in outs if o.stake_eur > 0]
    # —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: –ø–æ —É–±—ã–≤–∞–Ω–∏—é edge, –∑–∞—Ç–µ–º –ø–æ –¥–∞—Ç–µ/–≤—Ä–µ–º–µ–Ω–∏
    outs.sort(key=lambda x: (-x.edge, x.date, x.time))
    return outs

-----  end content  -----

[FILE] betai\pred_parser.py (1 KB)
----- begin content -----
# betai/pred_parser.py

"""
–ü–∞—Ä—Å–∏–Ω–≥ /predictions ‚Äì –¥–æ—Å—Ç–∞—ë–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –º–æ–¥–µ–ª–∏ –¥–ª—è 1X2,
–æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ –ø–æ–ª–µ predictions.percent –∏–∑ API-Football.
"""

from __future__ import annotations
from typing import Dict

def parse_predictions(data: Dict) -> Dict:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å –≤–∏–¥–∞:
    {
      '1X2': {'Home': 0.50, 'Draw': 0.50, 'Away': 0.00},
      'Total': {},  # –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –≤ —ç—Ç–æ–º —ç–Ω–¥–ø–æ–∏–Ω—Ç–µ
      'AH': {},     # –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –≤ —ç—Ç–æ–º —ç–Ω–¥–ø–æ–∏–Ω—Ç–µ
    }
    """
    resp = data.get("response")
    if not resp:
        return {"1X2": {}, "Total": {}, "AH": {}}

    pr = resp[0].get("predictions", {})
    pct = pr.get("percent", {})

    # percent —Ö—Ä–∞–Ω–∏—Ç —Å—Ç—Ä–æ–∫–∏ –≤—Ä–æ–¥–µ "50%", "0%", "25%"
    try:
        home = float(pct.get("home", "0%").strip("%")) / 100
        draw = float(pct.get("draw", "0%").strip("%")) / 100
        away = float(pct.get("away", "0%").strip("%")) / 100
    except Exception:
        home = draw = away = 0.0

    return {
        "1X2": {"Home": home, "Draw": draw, "Away": away},
        "Total": {},  # –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞
        "AH": {},     # –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞
    }

-----  end content  -----

[DIR ] betai.egg-info
[FILE] betai.egg-info\dependency_links.txt (0 KB)
----- begin content -----


-----  end content  -----

[FILE] betai.egg-info\PKG-INFO (0 KB)
----- begin content -----
Metadata-Version: 2.4
Name: betai
Version: 0.1.0
Requires-Dist: requests
Requires-Dist: sqlitedict
Requires-Dist: pydantic
Requires-Dist: python-dotenv
Requires-Dist: streamlit
Requires-Dist: pytz
Dynamic: requires-dist

-----  end content  -----

[FILE] betai.egg-info\requires.txt (0 KB)
----- begin content -----
requests
sqlitedict
pydantic
python-dotenv
streamlit
pytz

-----  end content  -----

[FILE] betai.egg-info\SOURCES.txt (0 KB)
----- begin content -----
setup.py
betai/__init__.py
betai/api.py
betai/constants.py
betai/markets_ru.py
betai/models.py
betai/odds_parser.py
betai/pipelines.py
betai/pred_parser.py
betai.egg-info/PKG-INFO
betai.egg-info/SOURCES.txt
betai.egg-info/dependency_links.txt
betai.egg-info/requires.txt
betai.egg-info/top_level.txt
tests/test_kelly.py
tests/test_pipelines.py
-----  end content  -----

[FILE] betai.egg-info\top_level.txt (0 KB)
----- begin content -----
betai

-----  end content  -----

[FILE] inspect_preds.py (1 KB)
----- begin content -----
# inspect_preds.py
import os
import json
from datetime import datetime, timezone
from dotenv import load_dotenv

# –≤–∞—à –º–æ–¥—É–ª—å API
from betai.api import get_fixtures, get_predictions

# –∑–∞–≥—Ä—É–∂–∞–µ–º .env
load_dotenv()

def main():
    # 1) –£–∫–∞–∂–∏—Ç–µ –¥–∞—Ç—É, –∑–∞ –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏–º –≥–ª—è–Ω—É—Ç—å –ø–µ—Ä–≤—ã–π –º–∞—Ç—á
    #    –§–æ—Ä–º–∞—Ç YYYY, M, D ‚Äî —Å–µ–≥–æ–¥–Ω—è:
    today = datetime.now(timezone.utc).date()
    
    # 2) –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
    fixtures = get_fixtures(today)["response"]
    if not fixtures:
        print("‚ùå –ù–µ—Ç –º–∞—Ç—á–µ–π –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –≤ —Ç–æ–ø-–ª–∏–≥–∞—Ö.")
        return
    
    # 3) –ò–∑–±–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π –ø–æ–ø–∞–≤—à–∏–π—Å—è –º–∞—Ç—á –∏–∑ —Ç–æ–ø-–ª–∏–≥ (ID –∏–∑ TOP_LEAGUES)
    #    –ó–¥–µ—Å—å —Ç—Ä—É–¥–Ω–æ –∑–Ω–∞—Ç—å –∑–∞—Ä–∞–Ω–µ–µ, –∫–∞–∫–∏–µ –ª–∏–≥–∏ –ø—Ä–∏–¥—É—Ç, –ø–æ—ç—Ç–æ–º—É –ø—Ä–æ—Å—Ç–æ –±–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π:
    fx = fixtures[0]
    fixture_id = fx["fixture"]["id"]
    print(f"–£ inspect_preds.py –ø–µ—Ä–≤—ã–π –º–∞—Ç—á fixture_id = {fixture_id}")
    
    # 4) –ó–∞–±–∏—Ä–∞–µ–º predictions
    preds = get_predictions(fixture_id)
    
    # 5) –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª / –ø–µ—á–∞—Ç–∞–µ–º –≤ –∫–æ–Ω—Å–æ–ª—å –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ
    print(json.dumps(preds, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    main()

-----  end content  -----

[FILE] pytest.ini (0 KB)
----- begin content -----
[pytest]
python_paths = .

-----  end content  -----

[FILE] requirements.txt (0 KB)
----- begin content -----
streamlit>=1.34
pandas>=2.2
requests>=2.32
python-dotenv>=1.0
pydantic>=2.7
sqlitedict>=2.1
tqdm>=4.66          # –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä –≤ —Ç–µ—Ä-–ª–æ–≥–µ
-----  end content  -----

[FILE] setup.py (0 KB)
----- begin content -----

from setuptools import setup, find_packages

setup(
    name="betai",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        # —Å—é–¥–∞ –≤—Å–µ –≤–∞—à–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä:
        "requests",
        "sqlitedict",
        "pydantic",
        "python-dotenv",
        "streamlit",
        "pytz",
    ],
)

-----  end content  -----

[FILE] snapshot.py (3 KB)
----- begin content -----
#!/usr/bin/env python3
"""
–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–ø–∞–∫—Ç–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç–∞ –ø—Ä–æ–µ–∫—Ç–∞.
–ò—Å–∫–ª—é—á–∞–µ—Ç –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –∏ –±–æ–ª—å—à–∏–µ —Ñ–∞–π–ª—ã (–≤–∫–ª—é—á–∞—è JSON-–¥–∞–º–ø—ã).
"""

from pathlib import Path
from datetime import datetime

# === –ù–∞—Å—Ç—Ä–æ–π–∫–∞ ===
PROJECT_DIR   = Path(r"C:\Code Projects\Bet_AI_pythone")  # –≤–∞—à –ø—Ä–æ–µ–∫—Ç
SNAP_DIR      = PROJECT_DIR / "snapshots"
MAX_SNAPS     = 5
MAX_INLINE_KB = 200  # –ø–æ—Ä–æ–≥ –¥–ª—è –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ

# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ —Ñ–∞–π–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –Ω—É–∂–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å
EXCLUDE_DIRS   = {".venv", "snapshots", "__pycache__", ".git", ".streamlit"}
EXCLUDE_NAMES  = {".env", "secrets.toml"}

# –†–∞—Å—à–∏—Ä–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ —Å—á–∏—Ç–∞—é—Ç—Å—è ¬´–±–∏–Ω–∞—Ä–Ω—ã–º–∏¬ª –∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–ø—É—Å–∫–∞—é—Ç—Å—è
BINARY_EXTS = {
    ".sqlite", ".db", ".log",
    ".png", ".jpg", ".jpeg", ".gif",
    ".bin", ".exe", ".pkl",
    ".json"    # —Ç–µ–ø–µ—Ä—å –∏—Å–∫–ª—é—á–∞–µ–º –∏ JSON-—Ñ–∞–π–ª—ã
}

# –°–æ–∑–¥–∞–¥–∏–º –ø–∞–ø–∫—É –¥–ª—è —Å–Ω–∞–ø—à–æ—Ç–æ–≤, –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
SNAP_DIR.mkdir(exist_ok=True)

# –ò–º—è –Ω–æ–≤–æ–≥–æ —Å–Ω–∞–ø—à–æ—Ç–∞
timestamp     = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
snapshot_file = SNAP_DIR / f"snapshot_{timestamp}.txt"


def should_skip(path: Path) -> bool:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–π –ø—É—Ç—å –Ω—É–∂–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å.
    """
    # –ø–æ —á–∞—Å—Ç–∏ –ø—É—Ç–∏ (–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è)
    if any(part in EXCLUDE_DIRS for part in path.parts):
        return True
    # –ø–æ —Ç–æ—á–Ω–æ–º—É –∏–º–µ–Ω–∏
    if path.name in EXCLUDE_NAMES:
        return True
    # –ø–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é
    if path.suffix.lower() in BINARY_EXTS:
        return True
    return False


def create_snapshot():
    with snapshot_file.open("w", encoding="utf-8") as out:
        out.write(f"=== Snapshot of {PROJECT_DIR} at {datetime.now()} ===\n\n")

        for p in sorted(PROJECT_DIR.rglob("*")):
            rel = p.relative_to(PROJECT_DIR)
            if should_skip(p):
                continue

            if p.is_dir():
                out.write(f"[DIR ] {rel}\n")
            else:
                size_kb = p.stat().st_size // 1024
                out.write(f"[FILE] {rel} ({size_kb} KB)\n")

                # –ï—Å–ª–∏ —Ñ–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ‚Äî –Ω–µ –≤—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
                if size_kb > MAX_INLINE_KB:
                    out.write(f"  # skipped content ({size_kb} KB > {MAX_INLINE_KB} KB)\n\n")
                    continue

                # –í—Å—Ç—Ä–æ–∏–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª
                try:
                    text = p.read_text(encoding="utf-8", errors="replace")
                except Exception as e:
                    out.write(f"  # unable to read file: {e}\n\n")
                    continue

                out.write("----- begin content -----\n")
                out.write(text)
                out.write("\n-----  end content  -----\n\n")

        out.write("=== End of snapshot ===\n")

    print(f"‚úÖ Snapshot saved to: {snapshot_file}")


def prune_old_snapshots():
    snaps = sorted(
        SNAP_DIR.glob("snapshot_*.txt"),
        key=lambda p: p.stat().st_mtime,
        reverse=True
    )
    for old in snaps[MAX_SNAPS:]:
        try:
            old.unlink()
            print(f"üóë Removed old snapshot: {old.name}")
        except Exception:
            pass


if __name__ == "__main__":
    create_snapshot()
    prune_old_snapshots()

-----  end content  -----

[DIR ] tests
[FILE] tests\test_kelly.py (0 KB)
----- begin content -----
from betai.models import Outcome, allocate_bank

def test_kelly_example():
    bank = 1000
    outs = [
        Outcome(fixture_id=1, date="", time="", league="", match="",
                market="1X2", pick_ru="", line=None,
                k_dec=2.10, p_model=0.540),
        Outcome(fixture_id=2, date="", time="", league="", match="",
                market="1X2", pick_ru="", line=None,
                k_dec=1.95, p_model=0.560),
        Outcome(fixture_id=3, date="", time="", league="", match="",
                market="1X2", pick_ru="", line=None,
                k_dec=3.60, p_model=0.310),
    ]
    for o in outs:
        o.compute_edge()
    allocate_bank(outs, bank)
    stakes = [o.stake_eur for o in outs]
    assert sum(stakes) == 150      # 15 % –±–∞–Ω–∫–∞

-----  end content  -----

[FILE] tests\test_pipelines.py (3 KB)
----- begin content -----
import pytest
from datetime import datetime, timezone
from betai.models import quick_prob, value_approx
from betai.pipelines import quick_screen, detailed_analysis
from betai.api import save_elo, load_elo

# Fixtures for Elo caching
def test_elo_cache(tmp_path, monkeypatch):
    # Setup a temporary DB file
    db_file = tmp_path / "test_elo.db"
    monkeypatch.setenv("BETAI_DB", str(db_file))
    # Ensure load returns None then save and load returns value
    team_id = 1
    date_str = "2025-05-20"
    assert load_elo(team_id, date_str) is None
    save_elo(team_id, date_str, 1550.0)
    assert load_elo(team_id, date_str) == pytest.approx(1550.0)

# Tests for quick_prob and value_approx
def test_quick_prob_symmetry():
    # If elo_home == elo_away, p_home ‚âà p_away and p_draw > 0
    p_h, p_d, p_a = quick_prob(1500, 1500)
    assert pytest.approx(p_h, rel=1e-2) == 0.5
    assert p_d > 0
    assert pytest.approx(p_h + p_d + p_a, rel=1e-6) == 1.0


def test_quick_prob_elo_difference():
    # Higher home elo yields p_h > 0.5
    p_h, p_d, p_a = quick_prob(1600, 1400)
    assert p_h > 0.5
    assert p_a < 0.5


def test_value_approx():
    assert value_approx(0.6, 2.0) == pytest.approx(1.2)

# Mocks for pipelines
class DummyFixture:
    def __init__(self):
        self.response = []

def test_quick_screen_filters(monkeypatch):
    # Monkeypatch get_fixtures to return controlled data
    from betai.pipelines import get_fixtures, get_odds, get_team_form

    fixtures_data = {
        "response": [
            {
                "league": {"id": 39, "name": "League A", "flag": ""},
                "fixture": {"id": 100, "timestamp": int(datetime.now(timezone.utc).timestamp()) + 3600},
                "teams": {"home": {"id": 10}, "away": {"id": 20}},
            }
        ]
    }
    monkeypatch.setattr("betai.pipelines.get_fixtures", lambda d: fixtures_data)
    monkeypatch.setattr("betai.pipelines.get_team_form", lambda team_id, last_n: [{}] * 10)
    # Patch odds: home odd=2.0, away=3.0
    odds_resp = {"response": [{"bookmakers": [{"bets": [{"name": "Match Winner", "values": [{"odd": 2.0}, {"odd": 3.0}]}]}]}]}
    monkeypatch.setattr("betai.pipelines.get_odds", lambda fid: odds_resp)
    # Run quick_screen
    candidates = quick_screen(days=1, top_n=1, completeness_thresh=0.8, value_thresh=0.0, p_min=0.0, p_max=1.0)
    assert len(candidates) == 2  # Home and Away should pass

def test_detailed_analysis_integration(monkeypatch):
    # Setup a dummy candidate
    candidate = {
        "league": {"name": "League A", "flag": ""},
        "fixture": {"id": 200, "timestamp": int(datetime.now(timezone.utc).timestamp()) + 7200},
        "teams": {"home": {"name": "Team H", "id": 10}, "away": {"name": "Team A", "id": 20}},
        "side": "Home",
        "k_mean": 2.0,
    }
    # Patch get_odds and get_predictions
    parse_odds = lambda _: [{"market": "1X2", "line": None, "pick_ru": "Home", "k_dec": 2.0, "side": "Home"}]
    parse_preds = lambda _: {"1X2": {None: {"Home": 0.6}}}
    monkeypatch.setattr("betai.pipelines.parse_odds", parse_odds)
    monkeypatch.setattr("betai.pipelines.parse_predictions", parse_preds)
    monkeypatch.setattr("betai.pipelines.get_odds", lambda fid: {})
    monkeypatch.setattr("betai.pipelines.get_predictions", lambda fid: {})

    outcomes = detailed_analysis([candidate], edge_min=0.0)
    assert len(outcomes) == 1
    out = outcomes[0]
    assert out.match == "Team H ‚Äì Team A"
    assert out.edge >= 0

-----  end content  -----

=== End of snapshot ===
